import{_ as s,o as p,c as l,O as n}from"./chunks/framework.571309da.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Spring/AOP通知类型【重点】.md","filePath":"guide/Spring/AOP通知类型【重点】.md","lastUpdated":1688356253000}'),a={name:"guide/Spring/AOP通知类型【重点】.md"},t=n(`<p><strong>问题导入</strong></p><p>请描述一下如何定义环绕通知方法？</p><p>7.1 AOP通知分类</p><ul><li><p>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p></li><li><p>AOP通知共分为5种类型</p><ul><li><p>前置通知：在切入点方法执行之前执行</p></li><li><p>后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。</p></li><li><p>**==环绕通知(重点)：==**手动调用切入点方法并对其进行增强的通知方式。</p></li><li><p>返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。</p></li><li><p>抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。</p></li></ul></li></ul><p>7.2 AOP通知详解</p><p>7.2.1 前置通知</p><ul><li><p>名称：@Before</p></li><li><p>类型：<strong>==方法注解==</strong></p></li><li><p>位置：通知方法定义上方</p></li><li><p>作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</p></li><li><p>范例：</p></li></ul><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">@Before(&quot;pt()&quot;)</span></span>
<span class="line"><span style="color:#A6ACCD;">public void before() {</span></span>
<span class="line"><span style="color:#A6ACCD;">    System.out.println(&quot;before advice ...&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>7.2.2 后置通知</p><ul><li><p>名称：@After</p></li><li><p>类型：==<strong>方法注解</strong>==</p></li><li><p>位置：通知方法定义上方</p></li><li><p>作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行</p></li><li><p>范例：</p></li></ul><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">@After(&quot;pt()&quot;)</span></span>
<span class="line"><span style="color:#A6ACCD;">public void after() {</span></span>
<span class="line"><span style="color:#A6ACCD;">    System.out.println(&quot;after advice ...&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>7.2.3 返回后通知</p><ul><li><p>名称：@AfterReturning（了解）</p></li><li><p>类型：<strong>==方法注解==</strong></p></li><li><p>位置：通知方法定义上方</p></li><li><p>作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行</p></li><li><p>范例：</p></li></ul><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">@AfterReturning(&quot;pt()&quot;)</span></span>
<span class="line"><span style="color:#A6ACCD;">public void afterReturning() {</span></span>
<span class="line"><span style="color:#A6ACCD;">    System.out.println(&quot;afterReturning advice ...&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>7.2.4 抛出异常后通知</p><ul><li><p>名称：@AfterThrowing（了解）</p></li><li><p>类型：<strong>==方法注解==</strong></p></li><li><p>位置：通知方法定义上方</p></li><li><p>作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行</p></li><li><p>范例：</p></li></ul><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">@AfterThrowing(&quot;pt()&quot;)</span></span>
<span class="line"><span style="color:#A6ACCD;">public void afterThrowing() {</span></span>
<span class="line"><span style="color:#A6ACCD;">    System.out.println(&quot;afterThrowing advice ...&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>7.2.5 环绕通知</p><ul><li><p>名称：@Around（重点，常用）</p></li><li><p>类型：<strong>==方法注解==</strong></p></li><li><p>位置：通知方法定义上方</p></li><li><p>作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行</p></li><li><p>范例：：</p></li></ul><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">@Around(&quot;pt()&quot;)</span></span>
<span class="line"><span style="color:#A6ACCD;">public Object around(ProceedingJoinPoint pjp) throws Throwable {</span></span>
<span class="line"><span style="color:#A6ACCD;">    System.out.println(&quot;around before advice ...&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">    Object ret = pjp.proceed();</span></span>
<span class="line"><span style="color:#A6ACCD;">    System.out.println(&quot;around after advice ...&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">    return ret;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>==<strong>环绕通知注意事项</strong>==</p><ol><li><p>环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。</p></li><li><p>环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。</p></li></ol>`,22),e=[t];function i(o,r,c,u,A,d){return p(),l("div",null,e)}const y=s(a,[["render",i]]);export{g as __pageData,y as default};
